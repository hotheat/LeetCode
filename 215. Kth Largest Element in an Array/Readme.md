`215.py` 利用快排的思想，选定一个主元，比主元大的放左边，比主元小的放右边。如果第 k 位大于分区后所在位置，从 [p+1: high] 处寻找，如果小于分区所在位置，从 [low: p-1] 处寻找。

最好情况下的时间复杂度，每次主元都恰好将数组一分为二，每次遍历的元素个数为
$$
n+\frac{n}{2}+\frac{n}{4}...+1\\
=\frac{n-\frac{1}{2}\times 1}{\frac{1}{2}}\\
=2n-1
$$
时间复杂度为 $O(n)$。

`pq.py` 另一种方法利用 PriorityQueue 来求解。

维护一个大小为 K 的小顶堆，当有数据被插入到集合中时，如果插入元素比堆顶元素大，那么弹出堆顶元素，插入该元素；如果比堆顶元素小，不做操作。最终的堆顶元素即第 K 大数。

时间复杂度为 $O(n\times logk)$。一次在堆中插入元素时间复杂度是 $log(k)$。
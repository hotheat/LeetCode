这道题可以看作是一道动态规划题。

每个数字由它前面的数字相乘以及它后面的数相乘得到。

第一遍遍历，记录当前索引的前面所有数字的乘积。prod(nums[0] ~ nums[i-1])，第一次遍历跳过第一个元素

第二遍遍历时，从后往前遍历，记录当前索引下后面所有数字的累积乘积，乘以当前索引前面所有数字乘积（已经存在数组中了）。prod(nums[i+1]~nums[n])，跳过最后一个元素。

![mark](http://qnpic.sijihaiyang.top/blog/20190305/cXQTsN2Fg3In.png?imageslim)

